// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drive.h"
#include "../RobotMap.h"
#include "../Commands/JoystickDrive.h"
#define MAX_ENC_SPEED 150

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drive::Drive() : Subsystem("Drive") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    rDrive = RobotMap::driverDrive;
    lDrive = RobotMap::drivelDrive;
    rEnc = RobotMap::driverEnc;
    lEnc = RobotMap::drivelEnc;
    ahrs = RobotMap::driveahrs;
    lEnc->SetPIDSourceType(PIDSourceType::kRate);
    lSpeedController.reset(new PIDController(-0.001, 0.0, 0.001,lEnc.get(), lDrive.get()));

    rEnc->SetPIDSourceType(PIDSourceType::kRate);
    rSpeedController.reset(new PIDController(0.001, 0.0, 0.001,rEnc.get(), rDrive.get()));


    /*speedControlConstantD = 0.0;
    speedControlConstantP = 0.0;
    speedControlConstantI = 0.0;
    rateRP = 0.0;
    rateRI = 0.0;
    rateRD = 0.0;
    rateLP = 0.0;
    rateLI = 0.0;
    rateLD = 0.0;*/
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drive::InitDefaultCommand() {
    // Set the default command for a subsystem here.
     SetDefaultCommand(new JoystickDrive());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drive::TankDrive(double l, double r, bool speedControl){
	printf("TankDrive: %f %f %d\n", l, r, speedControl);
	if (!speedControl)
	{
		if (lSpeedController->IsEnabled())
		{
			lSpeedController->Disable();
			rSpeedController->Disable();
		}
		frc::SmartDashboard::PutString("SpeedMode: ", "TankDrive");
		rDrive->Set(-r);
		lDrive->Set(l);
	}
	else
	{
		if (!lSpeedController->IsEnabled())
		{
			lSpeedController->Enable();
			rSpeedController->Enable();
		}
		frc::SmartDashboard::PutString("SpeedMode: ", "ClosedLoop");
		Drive::SpeedControlDrive(-l, -r);
	}
}


//Takes input as encoder ticks per second
void Drive::SpeedControlDrive(double l, double r)
{
	lSpeedController->SetSetpoint(l * 140);
	rSpeedController->SetSetpoint(r * 140);

	SmartDashboard::PutNumber("Speed Controller Error", lSpeedController->GetError());
	/*double errorR = (r - rEnc->GetRate()) / MAX_ENC_SPEED;
	double errorL = (l - lEnc->GetRate()) / MAX_ENC_SPEED;
	rateRI = rateRI + errorR;
	rateRD = errorR - rateRP;
	rateRP = errorR;

	rateLI = rateLI + errorL;
	rateLD = errorL - rateLP;
	rateLP = errorL;

	double rSpeed = rateRP * speedControlConstantP;
	double lSpeed = rateLP * speedControlConstantP;
	currentSpeedR += rSpeed;
	currentSpeedL += lSpeed;
	printf("e %d %d\n", l, r);
	printf("%d %d\n", currentSpeedL, currentSpeedR);
	rDrive->Set(-currentSpeedR);
	lDrive->Set(currentSpeedL);*/
}

double Drive::GetYaw()
{
	return ahrs->GetYaw();
}

void Drive::setPID(double p, double i, double d)
{
	/*speedControlConstantP = p;
	speedControlConstantI = i;
	speedControlConstantD = d;*/
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

