// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drive.h"
#include "../Commands/JoystickDrive.h"
#define MAX_ENC_SPEED 150

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drive::Drive() : Subsystem("Drive") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    rDrive = RobotMap::driverDrive;
    lDrive = RobotMap::drivelDrive;
   // rEnc = RobotMap::driverEnc;
   // lEnc = RobotMap::drivelEnc;
    ahrs = RobotMap::driveahrs;

   //lEnc->SetPIDSourceType(PIDSourceType::kRate);
   //lSpeedController.reset(new PIDController(-0.001, 0.0, 0.001,lEnc.get(), lDrive.get()));

    //rEnc->SetPIDSourceType(PIDSourceType::kRate);
    //rSpeedController.reset(new PIDController(0.001, 0.0, 0.001,rEnc.get(), rDrive.get()));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drive::InitDefaultCommand() {
    // Set the default command for a subsystem here.
     SetDefaultCommand(new JoystickDrive());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drive::TankDrive(double l, double r, bool speedControl){
	//printf("TankDrive: %f %f %d\n", l, r, speedControl);
	if (!speedControl)
	{
		SetControlMode(CANTalon::ControlMode::kPercentVbus);
		frc::SmartDashboard::PutString("SpeedMode: ", "TankDrive");
		rDrive->Set(-r);
		lDrive->Set(l);
	}
	else
	{
		printf("TRIGGERED");
		SetControlMode(CANTalon::ControlMode::kSpeed);
		frc::SmartDashboard::PutString("SpeedMode: ", "ClosedLoop");
		lDrive->Set(l * 2800);
		rDrive->Set(-r * 2800);
//		SpeedControlDrive(l, -r);
		printf("Set Point: %f \n", rDrive->GetSetpoint());
		frc::SmartDashboard::PutNumber("Talon output", rDrive->GetOutputVoltage());
	}
}


//Takes input as encoder ticks per second
void Drive::SpeedControlDrive(double l, double r)
{

	//printf("CONTROL MODE: %@ \n", rDrive->GetControlMode());

//	lSpeedController->SetSetpoint(l * 140);
//	rSpeedController->SetSetpoint(r * 140);

//	SmartDashboard::PutNumber("Speed Controller Error", lSpeedController->GetError());

}

double Drive::GetYaw()
{
	return ahrs->GetYaw();
}

void Drive::SetPID(double p, double i, double d, double f)
{
	rDrive->SetPID(p, i, d, f);
	lDrive->SetPID(p, i, d, f);
}

void Drive::SetControlMode(CANTalon::ControlMode mode)
{
	if (rDrive->GetControlMode() != mode)
		rDrive->SetControlMode(mode);
	if (lDrive->GetControlMode() != mode)
		lDrive->SetControlMode(mode);
	if (mode == CANTalon::ControlMode::kSpeed)
	{
		rDrive->SetPIDSourceType(PIDSourceType::kRate);
		lDrive->SetPIDSourceType(PIDSourceType::kRate);
		speedControlConstantP = 0.35;//SmartDashboard::GetNumber("Speed_P", 0);
		speedControlConstantI = 0.00004;//SmartDashboard::GetNumber("Speed_I", 0);
		speedControlConstantD = 0.053;//SmartDashboard::GetNumber("Speed_D", 0);
		speedControlConstantF = 0;
		double iZone = 600;//SmartDashboard::GetNumber("Speed_IZone", 0.0);

		rDrive->SetIzone(iZone);
		lDrive->SetIzone(iZone);
		SetPID(speedControlConstantP, speedControlConstantI, speedControlConstantD, speedControlConstantF);
	}
	if (mode == CANTalon::ControlMode::kPosition)
	{
		positionControlP = SmartDashboard::GetNumber("Pos_P", 0);
		positionControlI = SmartDashboard::GetNumber("Pos_I", 0);
		positionControlD = SmartDashboard::GetNumber("Pos_D", 0);
		SetPID(positionControlP, positionControlI, positionControlD, 0);
	}

}

void Drive::ResetTalonIntegral()
{
	rDrive->SetIzone(0);
	lDrive->SetIzone(0);
}

int Drive::GetREnc(){
	return rDrive->GetEncPosition();
}

int Drive::GetLEnc(){
	return lDrive->GetEncPosition();
}

int Drive::GetREncRate(){
	return rDrive->GetEncVel();
}

int Drive::GetLEncRate(){
	return lDrive->GetEncVel();
}

void Drive::DriveToTick(int tick){
	SetControlMode(CANTalon::ControlMode::kPosition);
	rDrive->Set(rDrive->GetEncPosition() + tick);
	lDrive->Set(lDrive->GetEncPosition() + tick);
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

