// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drive.h"
#include "../Commands/JoystickDrive.h"
#define MAX_ENC_SPEED 150

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drive::Drive() : Subsystem("Drive") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    rDrive = RobotMap::driverDrive;
    lDrive = RobotMap::drivelDrive;
    rEnc = RobotMap::driverEnc;
    lEnc = RobotMap::drivelEnc;
    ahrs = RobotMap::driveahrs;
   //lEnc->SetPIDSourceType(PIDSourceType::kRate);
   //lSpeedController.reset(new PIDController(-0.001, 0.0, 0.001,lEnc.get(), lDrive.get()));

    //rEnc->SetPIDSourceType(PIDSourceType::kRate);
    //rSpeedController.reset(new PIDController(0.001, 0.0, 0.001,rEnc.get(), rDrive.get()));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drive::InitDefaultCommand() {
    // Set the default command for a subsystem here.
     SetDefaultCommand(new JoystickDrive());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drive::TankDrive(double l, double r, bool speedControl){
	//printf("TankDrive: %f %f %d\n", l, r, speedControl);
	if (!speedControl)
	{
		SetControlMode(CANTalon::ControlMode::kPercentVbus);
		frc::SmartDashboard::PutString("SpeedMode: ", "TankDrive");
		rDrive->Set(-r);
		lDrive->Set(l);
	}
	else
	{
//		if (!lSpeedController->IsEnabled())
//		{
//			lSpeedController->Enable();
//			rSpeedController->Enable();
//		}
		SetControlMode(CANTalon::ControlMode::kSpeed);
		frc::SmartDashboard::PutString("SpeedMode: ", "ClosedLoop");
		Drive::SpeedControlDrive(l, -r);
	}
}


//Takes input as encoder ticks per second
void Drive::SpeedControlDrive(double l, double r)
{
	lDrive->Set(l * 140);
	rDrive->Set(r * 140);
//	lSpeedController->SetSetpoint(l * 140);
//	rSpeedController->SetSetpoint(r * 140);

//	SmartDashboard::PutNumber("Speed Controller Error", lSpeedController->GetError());

}

double Drive::GetYaw()
{
	return ahrs->GetYaw();
}

void Drive::SetPID(double p, double i, double d, double f)
{
	rDrive->SetPID(p, i, d, f);
	lDrive->SetPID(p, i, d, f);
}

void Drive::SetControlMode(CANTalon::ControlMode mode)
{
	if (rDrive->GetControlMode() != mode)
		rDrive->SetControlMode(mode);
	if (lDrive->GetControlMode() != mode)
		lDrive->SetControlMode(mode);
	if (mode == CANTalon::ControlMode::kSpeed)
	{
		rDrive->SetPIDSourceType(PIDSourceType::kRate);
		lDrive->SetPIDSourceType(PIDSourceType::kRate);
		SetPID(speedControlConstantP, speedControlConstantI, speedControlConstantD, 0);
	}
	if (mode == CANTalon::ControlMode::kPosition)
	{
		SetPID(positionControlP, positionControlI, positionControlD, 0);
	}

}

void Drive::DriveToTick(int tick){
	SetControlMode(CANTalon::ControlMode::kPosition);
	rDrive->Set(rDrive->GetEncPosition() + tick);
	lDrive->Set(lDrive->GetEncPosition() + tick);
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

